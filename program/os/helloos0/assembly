DB指令是“define byte”的缩写，也就是往文件里直接写入1个字节的指令。笔者喜欢用大写字母来写汇编指令，但小写的“db”也是一样的。

RESB指令是“reserve byte”的略写，如果想要从现在的地址开始空出10个字节来，就可以写成RESB 10，意思是我们预约了这10个字节,而且nask不仅仅是把指定的地址空出来，它还会在空出来的地址上自动填入0x00

“; ”命令，这是个注释命令，相当于C语言或是C++中的“//”。

其次是DB指令的新用法。我们居然可以直接用它写字符串。在写字符串的时候，汇编语言会自动地查找字符串中每一个字符所对应的编码，然后把它们一个字节一个字节地排列起来。

再有就是DW指令和DD指令，它们分别是“define word”和“define double-word”的缩写，是DB指令的“堂兄弟”。word的本意是“单词”，但在计算机汇编语言的世界里，word指的是“16位”的意思，也就是2个字节。“double-word”是“32位”的意思，也就是4个字节。

RESB 0x1fe-$: 在这个程序里，我们已经在前面输出了132字节，所以这里的$就是132。因此nask先用0x1fe减去132，得出378这一结果，然后连续输出378个字节的0x00。

首先是ORG指令。这个指令会告诉nask，在开始执行的时候，把这些机器语言指令装载到内存中的哪个地址。如果没有它，有几个指令就不能被正确地翻译和执行。另外，有了这条指令的话，美元符（$）的含义也随之变化，它不再是指输出文件的第几个字节，而是代表将要读入的内存地址。
ORG指令来源于英文“origin”，意思是“源头、起点”。它会告诉nask，程序要从指定的这个地址开始，也就是要把程序装载到内存中的指定地址。这里指定的地址是0x7c00

下一个是JMP指令，它相当于C语言的goto语句，来源于英文的jump，意思是“跳转”。

再下面是“entry:”，这是标签的声明，用于指定JMP指令的跳转目的地等。这与C语言很像。entry这个词是“入口”的意思。

    JMP     entry
    DB      0x90
entry:
    .....

MOV指令的使用次数也仅次于DB指令。这个指令的功能非常简单，即赋值。
    "MOV AX",0，相当于“AX=0; ”
    “MOV SS, AX”就相当于“SS=AX; ” 在执行了“MOV SS, AX”语句之后，AX并没有变“空”，还保留着原来的值不变。

CPU里有一种名为寄存器的存储电路，在机器语言中就相当于变量的功能。
    AX——accumulator，累加寄存器
    CX——counter，计数寄存器
    DX——data，数据寄存器
    BX——base，基址寄存器
    SP——stack pointer，栈指针寄存器
    BP——base pointer，基址指针寄存器
    SI——source index，源变址寄存器
    DI——destination index，目的变址寄存器

    这些寄存器全都是16位寄存器，因此可以存储16位的二进制数。虽然它们都有上面这种正式名称，但在平常使用的时候，人们往往用简单的英文字母来代替，称它们为“AX寄存器”、“SI寄存器”等。

    另一方面，CPU中还有8个8位寄存器。
    AL——累加寄存器低位（accumulator low）
    CL——计数寄存器低位（counter low）
    DL——数据寄存器低位（data low）
    BL——基址寄存器低位（base low）
    AH——累加寄存器高位（accumulator high）
    CH——计数寄存器高位（counter high）
    DH——数据寄存器高位（data high）
    BH——基址寄存器高位（base high）

    名字看起来有点像，其实这是有原因的：AX寄存器共有16位，其中0位到7位的低8位称为AL，而8位到15位的高8位称为AH。
    那BP、SP、SI、DI怎么没分为“L”和“H”呢？能这么想，就说明大家已经做到举一反三了，但可惜的是这几个寄存器不能分为“L”和“H”。如果无论如何都要分别取高位或低位数据的话，就必须先用“MOV, AX, SI”将SI的值赋到AX中去，然后再用AL、AH来取值。

    喂，我家的电脑是32位的，可不是16位。这样就能以32位为单位来处理数据了吧？那32位的寄存器在哪儿呀？
    EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI
    这些就是32位寄存器。这次的程序虽然没有用到它们，但如果想用也是完全可以使用的。在16位寄存器的名字前面加上一个E就是32位寄存器的名字了。这个字母E其实还是来源于“Extend”（扩展）这个词。

    虽说EAX是个32位寄存器，但其实跟前面一样，它有一部分是与AX共用的，32位中的低16位就是AX，而高16位既没有名字，也没有寄存器编号。也就是说，虽然我们可以把EAX作为2个16位寄存器来用，但只有低16位用起来方便；如果我们要用高16位的话，就需要使用移位命令，把高16位移到低16位后才能用。

    这些段寄存器都是16位寄存器。
    ES——附加段寄存器（extra segment）
    CS——代码段寄存器（code segment）
    SS——栈段寄存器（stack segment）
    DS——数据段寄存器（data segment）
    FS——没有名称（segment part 2）
    GS——没有名称（segment part 3）

    MOV AL, [SI] 可这里用方括号把SI括了起来。如果在汇编语言中出现这个方括号，寄存器所代表的意思就完全不一样了。
    这个记号代表“内存”。如果大家自己组装过电脑，就知道所谓“内存”，指的是256MB或512MB的那个零件
    MOV指令的数据传送源和传送目的地不仅可以是寄存器或常数，也可以是内存地址。这个时候，我们就使用方括号（[ ]）来表示内存地址。

    另外，BYTE、WORD、DWORD等英文词也都是汇编语言的保留字，下面举个例子吧。
    MOV BYTE [678],123
    电路中的某8个存储单元就会响应，这8个存储单元会记住代表“123”的开（ON）或关（OFF）的电信号。为什么是8位呢？这是因为指令里指定了“BYTE”

    MOV WORD [678], 123
    在这种情况下，内存地址中的678号和旁边的679号都会做出反应，一共是16位。这时，123被解释成一个16位的数值，也就是0000000001111011，低位的01111011保存在678号，高位的00000000保存在旁边的679号。

    像这样在汇编语言里指定内存地址时，要用下面这种方式来写：
    数据大小 [地址]
    如果我们指定“数据大小”为BYTE，那么使用的存储单元就只是地址所指定的字节。如果我们指定“数据大小”为WORD，则相邻的一个字节也会成为这个指令的操作对象。如果指定为DWORD，则与WORD相邻的两个字节，也都成为这个指令的操作对象（共4个字节）

    至于内存地址的指定方法，我们不仅可以使用常数，还可以用寄存器。比如“BYTE [SI]”、“WORD [BX]”等等。如果SI中保存的是987的话，“BYTE [SI]”就会被解释成“BYTE [987]”，即指定地址为987的内存。

    虽然我们可以用寄存器来指定内存地址，但可作此用途的寄存器非常有限，只有BX、BP、SI、DI这几个。剩下的AX、CX、DX、SP不能用来指定内存地址，这是因为CPU没有处理这种指令的电路，或者说没有表示这种处理的机器语言。

    所以想把DX内存里的内容赋值给AL的时候，就会这样写：
    MOV BX, DX
    MOV AL, BYTE [BX]

    可是MOV指令有一个规则，那就是源数据和目的数据必须位数相同。也就是说，能向AL里代入的就只有BYTE，这样一来就可以省略BYTE，即可以写成：
    MOV AL, [SI]

    ADD是加法指令。若以C语言的形式改写“ADD SI,1”的话，就是SI=SI+1。“add”的英文原语意为“加”。

    CMP是比较指令,即对a和3进行比较，将其翻译成机器语言时，必须先写“CMP a,3”，告诉CPU比较的对象，然后下一步再写“如果二者相等，需要做什么”。

    JE是条件跳转指令中之一。所谓条件跳转指令，就是根据比较的结果决定跳转或不跳转。就JE指令而言，如果比较结果相等，则跳转到指定的地址；而如果比较结果不等，则不跳转，继续执行下一条指令。
    CMP AL, 0
    JE fin

    这两条指令，就相当于：if (AL == 0) { goto fin; }

    INT是软件中断指令。

    电脑里有个名为BIOS的程序，出厂时就组装在电脑主板上的ROM单元里
    ROM:只读存储器，不能写入，切断电源后内容不会消失.read only memory的缩写

    最近的BIOS功能非常多，甚至包括了电脑的设定画面，不过它的本质正如其名，就是为操作系统开发人员准备的各种函数的集合。而INT就是用来调用这些函数的指令。INT的后面是个数字，使用不同的数字可以调用不同的函数。这次我们调用的是0x10（即16）号函数，它的功能是控制显卡。

    HLT是让CPU停止动作的指令，不过并不是彻底地停止（如果要彻底停止CPU的动作，只能切断电源），而是让CPU进入待机状态。只要外部发生变化，比如按下键盘，或是移动鼠标，CPU就会醒过来，继续执行程序。
    果没有HLT指令，CPU就会不停地全力去执行JMP指令，这会使CPU的负荷达到100%，非常费电。这多浪费呀。我们仅仅加上一个HLT指令，就能让CPU基本处于睡眠状态，可以省很多电。
    对了，HLT指令源自英文“halt”，意思是“停止”。

    我们还没有说ORG的0x7c00是怎么回事呢。ORG指令本身刚才已经讲过，就不再重复了，但这个0x7c00又是从哪儿冒出来的呢？换成1234是不是就不行啊？嗯，还真是不行，我们要是把它换成1234的话，程序马上就不动了。
    比如说，内存的0号地址，也就是最开始的部分，是BIOS程序用来实现各种不同功能的地方，如果我们随便使用的话，就会与BIOS发生冲突，结果不只是BIOS会出错，而且我们的程序也肯定会问题百出。另外，在内存的0xf0000号地址附近，还存放着BIOS程序本身，那里我们也不能使用。

    0x00007c00-0x00007dff ：启动区内容的装载地址
















